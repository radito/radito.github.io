[{"content":" Firmware router adalah perangkat lunak yang mengontrol fungsi router dan menyediakan antarmuka pengguna yang ramah untuk mengatur pengaturan jaringan. Ini adalah contoh dari sistem terbenam (embedded system), artinya perangkat lunak yang terintegrasi dalam perangkat keras. Jenis perangkat lunak ini dirancang khusus untuk beroperasi pada platform perangkat keras yang memiliki sumber daya terbatas, seperti router dengan memori dan daya proses yang terbatas.\nBiasanya untuk melakukan dump firmware menggunakan bantuan alat Programmer CH341A. Programmer EEPROM CH341A adalah alat populer yang digunakan untuk membaca dan menulis data ke chip EEPROM (Electrically Erasable Programmable Read-Only Memory). Dalam konteks sistem tertanam router, CH341A dapat digunakan untuk mengakses dan memodifikasi firmware yang disimpan dalam chip EEPROM router.\nChip EEPROM di router berisi firmware yang mengontrol operasi router, termasuk pengaturan konfigurasinya, protokol jaringan, dan parameter penting lainnya. Jika firmware ini rusak atau rusak, router mungkin gagal berfungsi dengan baik, atau bahkan menjadi tidak berfungsi sama sekali. Dalam kasus seperti itu, mungkin perlu menggunakan alat seperti CH341A untuk membaca firmware dari chip EEPROM, memodifikasinya seperlunya, dan kemudian menuliskannya kembali ke chip.\nCH341A terhubung ke chip EEPROM menggunakan satu set pin, yang biasanya dapat diakses di papan sirkuit router. Programmer kemudian dapat berkomunikasi dengan chip menggunakan protokol seperti SPI (Serial Peripheral Interface) atau I2C (Inter-Integrated Circuit), yang memungkinkannya membaca dan menulis data ke chip.\nKali ini kita akan lakukan tanpa bantuan Programmer CH341A dengan cara berikut. Untuk melakukan pembacaan firmware router, digunakan perintah mtd. Perintah mtd merupakan perintah bawaan dari linux di router tersebut.Subsystem MTD pada Linux menyediakan antarmuka yang terpadu untuk mengakses berbagai jenis perangkat memori flash. Utilitas MTD write adalah bagian dari subsistem ini dan memungkinkan pengguna untuk menulis data ke partisi MTD tertentu pada memori flash. Sebelum menggunakan utilitas MTD write, penting untuk mengidentifikasi lokasi dan ukuran perangkat memori flash menggunakan perintah \u0026ldquo;cat /proc/mtd\u0026rdquo;.\nLangkah Dump Firmware üí° Untuk dapat melakukan dump firmware router Bolt, pastikan anda sudah melakukan dan dapat mengakses root ‚Üí Lihat Tutorial\nLogin terlebih dahulu ke router melalui telnet. Setelah itu kita cek partisi flash dengan perintah cat /proc/mtd Nah disini terlihat bahwa router memiliki 7 partisi dari rentang 00000000 - 01000000 , Kita akan berfokus ke partisi mtd0 atau ALL. Karena partisi ini berisi semua informasi dari flash memory dari alamat paling awal hingga akhir.\nSetelah itu kita buat script downloadnya dengan mengetikkan perintah dibawah cat \u0026lt;\u0026lt;EOF \u0026gt; /etc_ro/lighttpd/www/cgi-bin/mtd.sh #!/bin/sh echo \u0026#34;Pragma: no-cache\\n\u0026#34; echo \u0026#34;Cache-control: no-cache\\n\u0026#34; echo \u0026#34;Content-type: application/octet-stream\u0026#34; echo \u0026#34;Content-Transfer-Encoding: binary\u0026#34; echo \u0026#34;Content-Disposition: attachment; filename=fw-dump.bin\u0026#34; echo \u0026#34;\u0026#34; cat /dev/mtd0 EOF chmod +x /etc_ro/lighttpd/www/cgi-bin/mtd.sh Setelah itu akses web dari router menggunakan ip address router tersebut. Setelah itu login dengan akun admin Pergi ke halaman cgi-bin/mtd.sh Contoh: http://192.168.1.123/cgi-bin/mtd.sh . Jika berhasil maka file fw-dump.bin akan berhasil terunduh. Setelah terunduh kita check filenya, disini ternyata bersarnya sekitar ~16 MB, sesuai dengan besar flash memory yang dimiliki router ini yaitu sebesar 16 MB. Kita cek isi dari file dengan menggunakan binwalk untuk mengetahui apa isi dari firmware yang telah diunduh. Sukses, file yang terunduh sudah berisi dengan firmware dari flash memory kita, disini dapat dilihat terdapat 7 address yang terdiri dari firmware, config, linux kernel, dll. Setelah ini tergantung dari kita mau menggunakan firmware ini untuk cek source code atau digunakan untuk restore backup ke flash memory ketika terjadi brick routernya. Sekian tutorial dump firmware router bolt BL-100 ‚ú®\nSelamat Mengoprek üëç\n","permalink":"https://radito.github.io/posts/bc8972d2-06af-42d9-b12e-df3cce60677a/","summary":"Firmware router adalah perangkat lunak yang mengontrol fungsi router dan menyediakan antarmuka pengguna yang ramah untuk mengatur pengaturan jaringan. Ini adalah contoh dari sistem terbenam (embedded system), artinya perangkat lunak yang terintegrasi dalam perangkat keras. Jenis perangkat lunak ini dirancang khusus untuk beroperasi pada platform perangkat keras yang memiliki sumber daya terbatas, seperti router dengan memori dan daya proses yang terbatas.\nBiasanya untuk melakukan dump firmware menggunakan bantuan alat Programmer CH341A.","title":"Dump Firmware Bolt BL-100 Tanpa Flash Reader"},{"content":"Apa itu Rooting ? Rooting pada perangkat atau sistem terbenam adalah proses untuk mendapatkan akses ke sistem operasi perangkat yang memungkinkan pengguna untuk memodifikasi file sistem dan pengaturan yang sebelumnya dibatasi. Rooting dapat memberikan manfaat seperti menginstal firmware kustom, menghapus perangkat lunak yang telah diinstal sebelumnya, menyesuaikan antarmuka pengguna perangkat, dan menyesuaikan pengaturan sistem.\nLangkah - Langkah Akses Root Bolt BL-100 üí° Versi Firmware yang digunakan adalah HW: rev 2 | SW: BOLT!4G v3.1.32\nAkses Web GUI router dengan mengetikkan IP Adress router ke browser Pergi ke menu Settings ‚Üí Administration Pergi ke menu Configuration ‚Üí Lalu terdapat button Export ‚Üí Klik button Export Setelah filter terdownload lalu buka file tar tersebut dengan code editor. Disini saya menggunakan Visual Studio Code, anda dapat menggunakan Vscode ataupun code editor lain, yang penting support file binary.\nSetelah filter terbuka klik CTRL + F lalu cari keyword LAN_Telnet\nUbah nilainya menjadi 1 sehingga LAN_Telnet=1 Kemudian cari lagi dengan keyword Login= Nah pada line Login dan Password tersebut merupakan akun untuk login ke root nya, catat nilainya untuk dipakai nanti, disini contohnya. Setiap router bisa berbeda jadi pastikan lagi di file konfigurasi anda. Login=admin Password=db40 Jika sudah klik simpan pada file yang telah diubah.\nAkses kembali halaman Configuration di Website router. Dan import file yang telah dimodifikasi tadi.\nKlik Upload dan router akan memproses file konfigurasi, setelah selesai maka router akan reboot dengan sendirinya dengan konfigurasi yang telah dimodifikasi. Testing Login ke Root Cek scan port pada router, muncul port 23 dimana port telnet router tersebut dijalankan. Lalu kita coba test login via telnet.\nYes, berhasil login ke router dengan user yang didapatkan dari file konfigurasi tadi (admin/db40). Kita coba check apakah kita mendapatkan privilege root dengan command id. Dan kita tes beberapa command lain.\nTernyata user admin memiliki uid=0 dan gid=0 artinya kita memiliki akses dengan level root, dan di file passwd hanya ada satu user saja yaitu admin.\nSekian tutorial akses root router bolt BL-100 ‚ú®\nSelamat Mengoprek üëç\n","permalink":"https://radito.github.io/posts/25149034-6a06-4629-b657-5d42dac4a9b2/","summary":"Apa itu Rooting ? Rooting pada perangkat atau sistem terbenam adalah proses untuk mendapatkan akses ke sistem operasi perangkat yang memungkinkan pengguna untuk memodifikasi file sistem dan pengaturan yang sebelumnya dibatasi. Rooting dapat memberikan manfaat seperti menginstal firmware kustom, menghapus perangkat lunak yang telah diinstal sebelumnya, menyesuaikan antarmuka pengguna perangkat, dan menyesuaikan pengaturan sistem.\nLangkah - Langkah Akses Root Bolt BL-100 üí° Versi Firmware yang digunakan adalah HW: rev 2 | SW: BOLT!","title":"Rooting Firmware Ori Bolt BL-100"},{"content":"Apa itu UART ? UART atau Universal Asynchronous Receiver/Transmitter adalah jenis port komunikasi serial pada komputer yang memungkinkan pengiriman dan penerimaan data secara asinkron antara perangkat. Port UART juga dikenal dengan sebutan port serial atau COM port. Biasanya, port UART digunakan untuk menghubungkan komputer dengan perangkat eksternal seperti modem, printer, atau perangkat pengukur, dan juga pada mikrokontroler untuk menghubungkan perangkat dan modul lainnya.\nLevel logika UART 5V dan 3.3V adalah dua level tegangan yang umum digunakan pada mikrokontroler dan sistem embedded. Level logika 5V digunakan untuk jarak pendek dan memerlukan voltase operasi 5V, sedangkan level logika 3.3V lebih hemat energi dan cocok untuk jarak transmisi yang lebih jauh dengan voltase operasi 3.3V. Modul konversi level logika atau modul level shifter dapat digunakan untuk mengubah level logika antara dua level tegangan yang berbeda.\nUART pinout merujuk pada pengaturan pin atau tata letak pin pada port komunikasi serial UART. Port UART memiliki beberapa pin yang terdiri dari Tx (transmit), Rx (receive), VCC, GND, dan mungkin juga memiliki pin lain seperti RTS (reqest to send) dan CTS (clear to send).\nBerikut ini adalah urutan pin pada port komunikasi serial UART yang umum digunakan:\nVCC: Pin ini digunakan untuk memberikan daya ke perangkat yang terhubung ke port UART. GND: Pin ini digunakan sebagai koneksi ground atau tanah listrik pada port UART. Tx: Pin ini digunakan untuk mentransmisikan data dari perangkat pengirim ke perangkat penerima. Rx: Pin ini digunakan untuk menerima data dari perangkat pengirim ke perangkat penerima. Alat yang Dibutuhkan Obeng Plus Pinset Modul USB to TTL ‚Üí Link Langkah - Langkah Buka terlebih dahulu modem bolt BL-100 dengan membuka sekrup di bagian bawah.\nJika casing sudah terbuka, lalu lepaskan kabel antenna di konektor U.FL yang mengarah ke bagian atas dengan menggunakan Pinset, lakukan dengan hati - hati agar konektor tidak rusak.\nLalu lepaskan sekrup yang menempel pada PCB.\nAngkat PCB dan Balik pada bagian bawahnya, anda akan melihat susunan pin seperti pada gambar dibawah.\nFokus di bagian Pin yang ditandai UART, disini sudah saya labeli untuk urutan pin dari kiri ke kanan dengan urutan 3.3 V, GND, TX, RX. Hubungkan ke USB to TTL dengan urutan seperti dibawah BOLT \u0026lt;=================\u0026gt; USB TO TTL GND -\u0026gt; GND TX -\u0026gt; RX RX -\u0026gt; TX Konfigurasi Serial Baud Rate: 57600 Parity Bit: 8N1 ‚õî Jangan menghubungkan PIN 3.3 V, karena akan menyebabkan short dan kerusakan pada router.\nSetelah itu colokkan USB to TTL terlebih dahulu ke komputer, baru nyalakan router dengan mencolokkan adaptor. Melihat Serial Port di Windows Untuk mengakses port serial dengan PuTTY, ikuti langkah-langkah berikut:\nUnduh Putty ‚Üí Download Buka PuTTY. Pada kategori Session, pilih \u0026ldquo;Serial\u0026rdquo; sebagai jenis koneksi. Di bawah \u0026ldquo;Serial line,\u0026rdquo; masukkan nomor port serial (misalnya COM1 atau /dev/ttyS0) yang ingin Anda hubungkan. Sesuaikan kecepatan dengan baud rate perangkat yang ingin Anda hubungkan. Di bawah \u0026ldquo;Connection type,\u0026rdquo; pilih \u0026ldquo;Serial.\u0026rdquo; Klik \u0026ldquo;Open\u0026rdquo; untuk memulai koneksi. Setelah terhubung, Anda seharusnya dapat mengirim dan menerima data melalui port serial menggunakan terminal PuTTY.\nMelihat Serial Port di Mac/Linux Untuk mengakses port di mac/linux anda dapat menggunakan program \u0026ldquo;screen\u0026rdquo; di Linux untuk mengakses port serial dengan mengikuti langkah-langkah berikut:\nPastikan usb to ttl sudah terhubung. Cek nama perangkat dengan perintah ls /dev | grep -i tty Buka terminal Linux dan jalankan perintah screen -S serialtty /dev/ttyS0 57600 untuk membuka port serial. Di sini, \u0026ldquo;-S serialtty\u0026rdquo; adalah untuk memberi nama sesi screen Anda, \u0026ldquo;/dev/ttyS0\u0026rdquo; adalah nama port serial yang Anda ingin buka, dan \u0026ldquo;115200\u0026rdquo; adalah kecepatan baud rate untuk perangkat yang terhubung. Setelah membuka port serial dengan \u0026ldquo;screen\u0026rdquo;, Anda akan melihat pesan \u0026ldquo;Press Enter to activate this console\u0026rdquo; di layar. Tekan tombol \u0026ldquo;Enter\u0026rdquo; untuk memulai sesi screen dan mengakses port serial. Untuk keluar dari sesi \u0026ldquo;screen\u0026rdquo;, tekan tombol \u0026ldquo;Ctrl + A\u0026rdquo; diikuti dengan tombol \u0026ldquo;K\u0026rdquo;, kemudian ketik \u0026ldquo;Y\u0026rdquo; dan tekan \u0026ldquo;Enter\u0026rdquo; untuk mengkonfirmasi. Untuk memulai kembali sesi \u0026ldquo;screen\u0026rdquo;, jalankan perintah \u0026ldquo;screen -r serialtty Setelah serial terbuka, jika semua step berjalan dengan lancar maka log serial akan muncul dengan sendirinya.\nSekian tutorial akses port serial router bolt BL-100 ‚ú®\nSelamat Mengoprek üëç\n","permalink":"https://radito.github.io/posts/fc30572e-a48e-4461-9776-2822965f34cc/","summary":"Apa itu UART ? UART atau Universal Asynchronous Receiver/Transmitter adalah jenis port komunikasi serial pada komputer yang memungkinkan pengiriman dan penerimaan data secara asinkron antara perangkat. Port UART juga dikenal dengan sebutan port serial atau COM port. Biasanya, port UART digunakan untuk menghubungkan komputer dengan perangkat eksternal seperti modem, printer, atau perangkat pengukur, dan juga pada mikrokontroler untuk menghubungkan perangkat dan modul lainnya.\nLevel logika UART 5V dan 3.3V adalah dua level tegangan yang umum digunakan pada mikrokontroler dan sistem embedded.","title":"Akses Port UART/Serial Bolt BL-100"},{"content":" üí° Apa itu Router ?\nRouter adalah perangkat jaringan yang meneruskan paket data antara jaringan komputer. Router terhubung dengan setidaknya dua jaringan, biasanya dua LAN (Local Area Network) atau WAN (Wide Area Network) atau LAN dan jaringan ISP (Internet Service Provider) nya. Router terletak di gerbang, tempat di mana dua atau lebih jaringan terhubung.\n‚ú≥Ô∏è ToDo List Oprek\nAkses Port UART/Serial Rooting Firmware Bawaan Dump Firmware Bawaan Install Mod USB Port Install Firmware OpenWRT Konfigurasi modem LTE di OpenWRT ‚ú≥Ô∏è Router Bolt dengan Modem LTE\nModem LTE adalah perangkat yang menyediakan konektivitas data nirkabel broadband. Ia menggunakan standar Long-Term Evolution (LTE) untuk terhubung ke internet, yang merupakan jaringan data kecepatan tinggi yang digunakan oleh banyak operator seluler di seluruh dunia. Modem LTE sering digunakan sebagai koneksi internet cadangan atau dalam situasi di mana internet kabel tidak tersedia. Mereka dapat digunakan untuk menyediakan akses internet ke satu perangkat atau untuk membuat jaringan nirkabel yang dapat diakses oleh beberapa perangkat.\nBolt adalah perusahaan telekomunikasi di Indonesia yang menyediakan layanan internet 4G LTE. Mereka menawarkan berbagai paket dan perangkat, termasuk router dengan modem LTE bawaan yang dapat digunakan untuk membuat jaringan nirkabel. BL-100 adalah salah satu router tersebut yang tersedia untuk dibeli.\nSpesifikasi Bolt BL-100 Chipset Mediatek MT7620 (580 MHz) RAM 64 MB Bootloader U Boot Flash Winbond W25Q128BV (16 MB) Port 2x 10/100 Ethernet, 1x RJ-11 VoIP Modem Qualcomm LTE B40 (2300 Mhz) VID:05c6 PID:9026 Wireless Ralink RT2860 (2.4 Ghz) \u0026amp; Mediatek MT7612E (5.8 Ghz) Voltage DC 12V 1A Antenna Port 2x External Antenna, 2 LTE U.FL , 2 WiFi U.FL Serial Port Yes, 3.3 V TTL, Baud 57600 8N1 Dengan menggunakan chipset mt7620 modem bolt bl 100 merupakan modem yang cukup mumpuni, karena sudah dilengkapi dengan modem lte + wireless dual band yang dapat menjadikan router ini sebagai andalan router rumahan. Selain itu chipset mt7620 sudah mendapatkan dukungan dari openwrt dan komunitas opreker lainnya sehingga kita bisa dengan mudah melakukan porting ke router ini.\nGambar diatas merupakan datasheet chipset MT7620 [LINK]. Chipset MT7620 didalamnya dilengkapi dengan beberapa fitur diataranya USB, SDHC, PCIe, Wifi, Switch, SPI, UART, etc. Fitur ini merupakan fitur utama dari chipset tersebut dan menurut saya fitur tersebut sangat lengkap jika fungsinya ingin digunakan pada embedded device seperti router. Karena fitur utama yang digunakan biasanya hanya Ethernet, WIFI, dan port USB untuk LTE.\nMT7620 sendiri menggunakan arsitektur MIPS. MIPS adalah RISC (reduced instruction set computing) arsitektur set instruksi yang dikembangkan oleh beberapa peneliti Stanford pada pertengahan 1980-an. Awalnya, nama tersebut merupakan singkatan dari Microprocessor without Interlocked Pipeline Stages, tetapi interlock antara tahapan pipeline akhirnya diperkenalkan kembali, hal ini karena alasan kinerja karena prosesor lain menjadi lebih maju.\nArsitektur MIPS memainkan peran utama dalam pasar prosesor tertanam (Embedded) dan ratusan pelanggan terus menggunakannya secara komersial, termasuk Teknologi Microchip, Mobileye, dan MediaTek. Pengaplikasian MIPS pada umumnya adalah set-top box, gateway internet, dan router.\nFoto PCB Bolt BL-100 Berikut adalah beberapa foto Mainboard/PCB bolt BL100. Gambar dibawah dapat digunakan untuk referensi opreker/modding.\nInformasi Tambahan Cpu Info # cat /proc/cpuinfo system type : MT7620 processor : 0 cpu model : MIPS 24Kc V5.0 BogoMIPS : 385.84 wait instruction : yes microsecond timers : yes tlb_entries : 32 extra interrupt vector : yes hardware watchpoint : yes, count: 4, address/irw mask: [0x0004, 0x0b7c, 0x0ff8, 0x03c3] ASEs implemented : mips16 dsp shadow register sets : 1 core : 0 VCED exceptions : not available VCEI exceptions : not available Partition Information # cat /proc/mtd dev: size erasesize name mtd0: 01000000 00010000 \u0026#34;ALL\u0026#34; mtd1: 00030000 00010000 \u0026#34;Bootloader\u0026#34; mtd2: 00010000 00010000 \u0026#34;Config\u0026#34; mtd3: 00010000 00010000 \u0026#34;Factory\u0026#34; mtd4: 009b0000 00010000 \u0026#34;Kernel\u0026#34; mtd5: 005f0000 00010000 \u0026#34;Kernel2\u0026#34; mtd6: 00010000 00010000 \u0026#34;SmsInfo\u0026#34; Kernel Information # cat /proc/version Linux version 2.6.36 (daniel@test-virtual-machine) (gcc version 3.4.2) #1 PREEMPT Mon Oct 16 17:44:26 CST 2017 Free Memory # free total used free shared buffers Mem: 58484 48016 10468 0 0 Swap: 0 0 0 Total: 58484 48016 10468 Top Process # top CPU: 8% usr 8% sys 0% nic 83% idle 0% io 0% irq 0% sirq Load average: 1.22 1.36 1.44 1/71 31850 PID PPID USER STAT VSZ %VSZ %CPU COMMAND 31847 23639 admin R 2012 3% 8% top 4381 4377 admin S 4084 7% 0% lighttpd -D -f /etc_ro/lighttpd/lightt 5488 5487 admin S 3512 6% 0% AskeyCM 5504 5487 admin S 3512 6% 0% AskeyCM 5511 5487 admin S 3512 6% 0% AskeyCM 5516 5487 admin S 3512 6% 0% AskeyCM 4707 1 admin S 3512 6% 0% AskeyCM 5487 4707 admin S 3512 6% 0% AskeyCM 5490 5487 admin S 3512 6% 0% AskeyCM 5505 5487 admin S 3512 6% 0% AskeyCM 5491 5487 admin S 3512 6% 0% AskeyCM 5512 5487 admin S 3512 6% 0% AskeyCM 5052 5039 admin S 2744 5% 0% /usr/d2/vapp -i 192.168.1.123 5051 5039 admin S 2744 5% 0% /usr/d2/vapp -i 192.168.1.123 4773 1 admin S 2744 5% 0% /usr/d2/vapp -i 192.168.1.123 5047 5039 admin S 2744 5% 0% /usr/d2/vapp -i 192.168.1.123 5045 5039 admin S 2744 5% 0% /usr/d2/vapp -i 192.168.1.123 5050 5039 admin S 2744 5% 0% /usr/d2/vapp -i 192.168.1.123 5041 5039 admin S 2744 5% 0% /usr/d2/vapp -i 192.168.1.123 ^C042 5039 admin S 2744 5% 0% /usr/d2/vapp -i 192.168.1.123 Log Serial U-Boot 1.1.3 (Jun 8 2016 - 16:40:15) Board: APSoC DRAM: 64 MB relocate_code Pointer at: 83fb8000 enable ephy clock...done. rf reg 29 = 5 SSC disabled. spi_wait_nsec: 29 spi device id: ef 40 18 0 0 (40180000) find flash: W25Q128BV raspi_read: from:30000 len:1000 *** Warning - bad CRC, using default environment ============================================ LTE Router Version: 2.0.5 -------------------------------------------- ASIC 7620_MP (Port5\u0026lt;-\u0026gt;None) DRAM component: 512 Mbits DDR, width 16 DRAM bus: 16 bit Total memory: 64 MBytes Flash component: 16 MBytes NOR Flash Date:Jun 8 2016 Time:16:40:15 ============================================ raspi_read: from:30000 len:10000 Erasing SPI Flash... raspi_erase: offs:30000 len:10000 . Writing to SPI Flash... raspi_write: to:30000 len:10000 . done raspi_read: from:30000 len:10000 Erasing SPI Flash... raspi_erase: offs:30000 len:10000 . Writing to SPI Flash... raspi_write: to:30000 len:10000 . done raspi_read: from:30000 len:10000 Erasing SPI Flash... raspi_erase: offs:30000 len:10000 . Writing to SPI Flash... raspi_write: to:30000 len:10000 . done Release Version ! raspi_read: from:30000 len:10000 Erasing SPI Flash... raspi_erase: offs:30000 len:10000 . Writing to SPI Flash... raspi_write: to:30000 len:10000 . done icache: sets:512, ways:4, linesz:32 ,total:65536 dcache: sets:256, ways:4, linesz:32 ,total:32768 ##### The CPU freq = 580 MHZ #### estimate memory size =64 Mbytes 3: System Boot system code via Flash. ## Booting image at bc050000 ... raspi_read: from:30000 len:10000 Erasing SPI Flash... raspi_erase: offs:30000 len:10000 . Writing to SPI Flash... raspi_write: to:30000 len:10000 . done raspi_read: from:50000 len:40 Image Name: Linux Kernel Image Image Type: MIPS Linux Kernel Image (lzma compressed) Data Size: 6314347 Bytes = 6 MB Load Address: 80000000 Entry Point: 8000c4b0 raspi_read: from:50040 len:60596b Verifying Checksum ... OK Uncompressing Kernel Image ... OK No initrd ## Transferring control to Linux (at address 8000c4b0) ... ## Giving linux memsize in MB, 64 Starting kernel ... LINUX started... THIS IS ASIC Linux version 2.6.36 (daniel@test-virtual-machine) (gcc version 3.4.2) #1 PREEMPT Mon Oct 16 17:44:26 CST 2017 The CPU feqenuce set to 580 MHz MIPS CPU sleep mode enabled. PCIE: bypass PCIe DLL. PCIE: Elastic buffer control: Addr:0x68 -\u0026gt; 0xB4 disable all power about PCIe CPU revision is: 00019650 (MIPS 24Kc) Software DMA cache coherency Determined physical RAM map: memory: 04000000 @ 00000000 (usable) Initrd not found or empty - disabling initrd Zone PFN ranges: Normal 0x00000000 -\u0026gt; 0x00004000 Movable zone start PFN for each node early_node_map[1] active PFN ranges 0: 0x00000000 -\u0026gt; 0x00004000 Built 1 zonelists in Zone order, mobility grouping on. Total pages: 16256 Kernel command line: console=ttyS1,57600n8 root=/dev/ram0 console=ttyS0 PID hash table entries: 256 (order: -2, 1024 bytes) Dentry cache hash table entries: 8192 (order: 3, 32768 bytes) Inode-cache hash table entries: 4096 (order: 2, 16384 bytes) Primary instruction cache 64kB, VIPT, , 4-waylinesize 32 bytes. Primary data cache 32kB, 4-way, PIPT, no aliases, linesize 32 bytes Writing ErrCtl register=0007e6b8 Readback ErrCtl register=0007e6b8 Memory: 54196k/65536k available (4955k kernel code, 11340k reserved, 1227k data, 4288k init, 0k highmem) NR_IRQS:128 console [ttyS1] enabled Calibrating delay loop... 385.84 BogoMIPS (lpj=1929216) pid_max: default: 32768 minimum: 301 Mount-cache hash table entries: 512 NET: Registered protocol family 16 RALINK_GPIOMODE = 141710 RALINK_GPIOMODE = 141710 PPLL_CFG1=0xe54000 MT7620 PPLL lock PPLL_DRV =0x80080504 start PCIe register access RALINK_RSTCTRL = 2400000 RALINK_CLKCFG1 = 75afffc0 *************** MT7620 PCIe RC mode ************* PCIE0 enabled Port 0 N_FTS = 1b105000 init_rt2880pci done bio: create slab \u0026lt;bio-0\u0026gt; at 0 vgaarb: loaded SCSI subsystem initialized usbcore: registered new interface driver usbfs usbcore: registered new interface driver hub usbcore: registered new device driver usb pci 0000:00:00.0: BAR 0: can\u0026#39;t assign mem (size 0x80000000) pci 0000:00:00.0: BAR 8: assigned [mem 0x20000000-0x200fffff] pci 0000:00:00.0: BAR 9: assigned [mem 0x20100000-0x201fffff pref] pci 0000:00:00.0: BAR 1: assigned [mem 0x20200000-0x2020ffff] pci 0000:00:00.0: BAR 1: set to [mem 0x20200000-0x2020ffff] (PCI address [0x20200000-0x2020ffff] pci 0000:01:00.0: BAR 0: assigned [mem 0x20000000-0x200fffff 64bit] pci 0000:01:00.0: BAR 0: set to [mem 0x20000000-0x200fffff 64bit] (PCI address [0x20000000-0x200fffff] pci 0000:01:00.0: BAR 6: assigned [mem 0x20100000-0x2010ffff pref] pci 0000:00:00.0: PCI bridge to [bus 01-01] pci 0000:00:00.0: bridge window [io disabled] pci 0000:00:00.0: bridge window [mem 0x20000000-0x200fffff] pci 0000:00:00.0: bridge window [mem 0x20100000-0x201fffff pref] BAR0 at slot 0 = 0 bus=0x0, slot = 0x0 res[0]-\u0026gt;start = 0 res[0]-\u0026gt;end = 0 res[1]-\u0026gt;start = 20200000 res[1]-\u0026gt;end = 2020ffff res[2]-\u0026gt;start = 0 res[2]-\u0026gt;end = 0 res[3]-\u0026gt;start = 0 res[3]-\u0026gt;end = 0 res[4]-\u0026gt;start = 0 res[4]-\u0026gt;end = 0 res[5]-\u0026gt;start = 0 res[5]-\u0026gt;end = 0 bus=0x1, slot = 0x0 res[0]-\u0026gt;start = 20000000 res[0]-\u0026gt;end = 200fffff res[1]-\u0026gt;start = 0 res[1]-\u0026gt;end = 0 res[2]-\u0026gt;start = 0 res[2]-\u0026gt;end = 0 res[3]-\u0026gt;start = 0 res[3]-\u0026gt;end = 0 res[4]-\u0026gt;start = 0 res[4]-\u0026gt;end = 0 res[5]-\u0026gt;start = 0 res[5]-\u0026gt;end = 0 Switching to clocksource Ralink Systick timer NET: Registered protocol family 2 IP route cache hash table entries: 1024 (order: 0, 4096 bytes) TCP established hash table entries: 2048 (order: 2, 16384 bytes) TCP bind hash table entries: 2048 (order: 1, 8192 bytes) TCP: Hash tables configured (established 2048 bind 2048) TCP reno registered UDP hash table entries: 256 (order: 0, 4096 bytes) UDP-Lite hash table entries: 256 (order: 0, 4096 bytes) NET: Registered protocol family 1 Load Ralink Timer0 Module Load Ralink Timer1 Module RT3xxx EHCI/OHCI init. fuse init (API version 7.15) msgmni has been set to 105 Block layer SCSI generic (bsg) driver version 0.4 loaded (major 254) io scheduler noop registered (default) Set the GPIO 32 data 0x0000FEFF get gpio Dir 2FF9 get gpio data EEF Ralink gpio driver initialized Serial: 8250/16550 driver, 2 ports, IRQ sharing disabled serial8250: ttyS0 at MMIO 0x10000500 (irq = 37) is a 16550A serial8250: ttyS1 at MMIO 0x10000c00 (irq = 12) is a 16550A brd: module loaded deice id : ef 40 18 0 0 (40180000) W25Q128BV(ef 40180000) (16384 Kbytes) mtd .name = raspi, .size = 0x01000000 (0M) .erasesize = 0x00000010 (0K) .numeraseregions = 65536 Creating 7 MTD partitions on \u0026#34;raspi\u0026#34;: 0x000000000000-0x000001000000 : \u0026#34;ALL\u0026#34; 0x000000000000-0x000000030000 : \u0026#34;Bootloader\u0026#34; 0x000000030000-0x000000040000 : \u0026#34;Config\u0026#34; 0x000000040000-0x000000050000 : \u0026#34;Factory\u0026#34; 0x000000050000-0x000000a00000 : \u0026#34;Kernel\u0026#34; 0x000000a00000-0x000000ff0000 : \u0026#34;Kernel2\u0026#34; 0x000000ff0000-0x000001000000 : \u0026#34;SmsInfo\u0026#34; rdm_major = 253 SMACCR1 -- : 0x0000e8d1 SMACCR0 -- : 0x1b075a79 Ralink APSoC Ethernet Driver Initilization. v3.1 256 rx/tx descriptors allocated, mtu = 1500! SMACCR1 -- : 0x0000e8d1 SMACCR0 -- : 0x1b075a79 PROC INIT OK! PPP generic driver version 2.4.2 PPP MPPE Compression module registered NET: Registered protocol family 24 PPTP driver version 0.8.5 IMQ driver loaded successfully. Hooking IMQ after NAT on PREROUTING. Hooking IMQ before NAT on POSTROUTING. usbcore: registered new interface driver cdc_ether usbcore: registered new interface driver cdc_subset === pAd = c0282000, size = 2173688 === \u0026lt;-- RTMPAllocTxRxRingMemory, Status=0 \u0026lt;-- RTMPAllocAdapterBlock, Status=0 device_id =0x7662 ==\u0026gt;rlt_wlan_chip_onoff(): OnOff:1, Reset= 1, pAd-\u0026gt;WlanFunCtrl:0x0, Reg-WlanFunCtrl=0x20a RtmpChipOpsEepromHook::e2p_type=0, inf_Type=5 RtmpEepromGetDefault::e2p_dafault=2 NVM is efuse and the information is too less to bring up the interface Force to use Flash mode NVM is FLASH mode (pAd-\u0026gt;flash_offset = 0x48000) get_dev_name_prefix(): dev_idx = 1, dev_name_prefix=rai === pAd = c0497000, size = 2173688 === \u0026lt;-- RTMPAllocTxRxRingMemory, Status=0 \u0026lt;-- RTMPAllocAdapterBlock, Status=0 RtmpChipOpsEepromHook::e2p_type=0, inf_Type=4 RtmpEepromGetDefault::e2p_dafault=2 NVM is FLASH mode (pAd-\u0026gt;flash_offset = 0x40000) get_dev_name_prefix(): dev_idx = 0, dev_name_prefix=ra ehci_hcd: USB 2.0 \u0026#39;Enhanced\u0026#39; Host Controller (EHCI) Driver rt3xxx-ehci rt3xxx-ehci: Ralink EHCI Host Controller rt3xxx-ehci rt3xxx-ehci: new USB bus registered, assigned bus number 1 rt3xxx-ehci rt3xxx-ehci: irq 18, io mem 0x101c0000 rt3xxx-ehci rt3xxx-ehci: USB 0.0 started, EHCI 1.00 hub 1-0:1.0: USB hub found hub 1-0:1.0: 1 port detected ohci_hcd: USB 1.1 \u0026#39;Open\u0026#39; Host Controller (OHCI) Driver rt3xxx-ohci rt3xxx-ohci: RT3xxx OHCI Controller rt3xxx-ohci rt3xxx-ohci: new USB bus registered, assigned bus number 2 rt3xxx-ohci rt3xxx-ohci: irq 18, io mem 0x101c1000 hub 2-0:1.0: USB hub found hub 2-0:1.0: 1 port detected usbcore: registered new interface driver cdc_acm cdc_acm: v0.26:USB Abstract Control Model driver for USB modems and ISDN adapters Initializing USB Mass Storage driver... usbcore: registered new interface driver usb-storage USB Mass Storage support registered. MTK MSDC device init. msdc0 -\u0026gt; ops_get_cd return\u0026lt;0\u0026gt; \u0026lt;- msdc_ops_get_cd() : L\u0026lt;2317\u0026gt; PID\u0026lt;kworker/u:1\u0026gt;\u0026lt;0x1a\u0026gt; mtk-sd: MediaTek MT6575 MSDC Driver GACT probability on Mirror/redirect action on Simple TC action Loaded netem: version 1.2 u32 classifier Performance counters on input device check on Actions configured Netfilter messages via NETLINK v0.30. nf_conntrack version 0.5.0 (846 buckets, 3384 max) ctnetlink v0.93: registering with nfnetlink. nf_conntrack_rtsp v0.6.21 loading matchsize=264 xt_time: kernel timezone is -0000 IPVS: Registered protocols () IPVS: Connection hash table configured (size=4096, memory=32Kbytes) IPVS: ipvs loaded. GRE over IPv4 demultiplexor driver gre: can\u0026#39;t add protocol nf_nat_rtsp v0.6.21 loading ip_tables: (C) 2000-2006 Netfilter Core Team, Type=Restricted Cone arp_tables: (C) 2002 David S. Miller TCP cubic registered NET: Registered protocol family 10 NET: Registered protocol family 17 Bridge firewalling registered L2TP core driver, V2.0 PPPoL2TP kernel driver, V2.0 802.1Q VLAN Support v1.8 Ben Greear \u0026lt;greearb@candelatech.com\u0026gt; All bugs added by David S. Miller \u0026lt;davem@redhat.com\u0026gt; Warning: unable to open an initial console. Freeing unused kernel memory: 4288k freed Algorithmics/MIPS FPU Emulator v1.5 Welcome to __ ___ _____ _____ _ _______ ______ _____ _ ___ | \\ / || ___|| __ \\ | || __ ||__ __|| ___|| | / / | ^ || |__ | | \\ \\| || | | | | | | |__ | |/ / | | | || ___|| | | || || |__| | | | | ___|| \\ | | | || |___ | |__/ /| || __ | | | | |___ | |\\ \\ |__| |___||_____||_____/ |_||_| |_| |_| |_____||_| \\__\\ = Everyday Genius = GobiNet: 2011-07-29-1026 usbcore: registered new interface driver GobiNet [CC] [12] init daemon... cat: can\u0026#39;t open \u0026#39;/var/run/LteManager.status\u0026#39;: No such file or directory Password for \u0026#39;admin\u0026#39; changed ##### disable 1st wireless interface ##### ##### disable 2nd wireless interface ##### rmmod: rlt_wifi: No such file or directory insmod: rlt_wifi.ko: module not found cat: can\u0026#39;t open \u0026#39;/var/run/LteManager.status\u0026#39;: No such file or directory RX[0] DESC a21ec000 size = 4096 RX[1] DESC a21ed000 size = 4096 E2pAccessMode=0 cfg_mode=9 cfg_mode=9 wmode_band_equal(): Band Equal! 1. Phy Mode = 14 Country Region from e2p = ffff 2. Phy Mode = 14 3. Phy Mode = 14 AntCfgInit: primary/secondary ant 0/1 Current Temperature from BBP_R49=0xfffffff8 RT6352_TssiTableAdjust: upper_bound = 0x7F decimal: 127 RT6352_TssiTableAdjust: lower_bound = 0xFFFFFF80 decimal: -128 *** RT6352_TssiTableAdjust: G Tssi[-7 .. +7] = -128 -1 -1 -1 -128 -1 -1 - -1 - -1 -1 -1 -1 -1 -1 -1, offset=-9, tuning=0 RT6352_TssiTableAdjust: G Tssi[-7 .. +7] = -128 -10 -10 -10 -128 -10 -10 - -10 - -10 -10 -10 -10 -10 -10 -10, offset=-9, tuning=0 mp_temperature=0x00, step = +7 E2PROM: G Tssi[-7 .. +7] = -128 -10 -10 -10 -128 -10 -10 - -10 - -10 -10 -10 -10 -10 -10 -10, offset=-9, tuning=0 ChipStructAssign(): RALINK6352 hook ! bAutoTxAgcG = 0 MCS Set = ff ff 00 00 01 APStartUp(): AP Set CentralFreq at 7(Prim=9, HT-CentCh=7, VHT-CentCh=0, BBP_BW=1) Main bssid = e8:d1:1b:07:5a:7b \u0026lt;==== rt28xx_init, Status=0 get_dev_name_prefix(): dev_idx = 0, dev_name_prefix=wds get_dev_name_prefix(): dev_idx = 0, dev_name_prefix=wds get_dev_name_prefix(): dev_idx = 0, dev_name_prefix=wds get_dev_name_prefix(): dev_idx = 0, dev_name_prefix=wds get_dev_name_prefix(): dev_idx = 0, dev_name_prefix=apcli RTMPDrvOpen(1):Check if PDMA is idle! RTMPDrvOpen(2):Check if PDMA is idle! build time = 20141115060606a rom patch for E3 IC platform = ALPS hw/sw version = ÔøΩÔøΩ patch version = FW Version:0.0.00 Build:1 Build Time:201507311614____ fw for E3 IC RX[0] DESC a278b000 size = 4096 RX[1] DESC a278c000 size = 4096 E2pAccessMode=0 cfg_mode=14 cfg_mode=14 wmode_band_equal(): Band Not Equal! 1. Phy Mode = 49 drivers/net/wireless/rlt_wifi_ap/../rlt_wifi_p1/chips/mt76x2.c:2844 assert (ad-\u0026gt;TxPower[choffset].Channel == 42)failed Country Region from e2p = ffff 2. Phy Mode = 49 3. Phy Mode = 49 andes_pci_fw_init 0x1300 = 00073200 AntCfgInit: primary/secondary ant 0/1 andes_load_cr:cr_type(2) ChipStructAssign(): MT76x2 hook ! bAutoTxAgcG = 0 MCS Set = ff ff 00 00 01 mt76x2_bbp_adjust():rf_bw=2, ext_ch=1, PrimCh=157, HT-CentCh=159, VHT-CentCh=155 TX0 power compensation = 0x38 TX1 power compensation = 0x38 APStartUp(): AP Set CentralFreq at 155(Prim=157, HT-CentCh=159, VHT-CentCh=155, BBP_BW=2) mt76x2_calibration(channel = 155) Main bssid = e8:d1:1b:07:5a:7c mt76x2_reinit_agc_gain:original agc_vga0 = 0x5c, agc_vga1 = 0x5c mt76x2_reinit_agc_gain:updated agc_vga0 = 0x5c, agc_vga1 = 0x5c mt76x2_reinit_hi_lna_gain:original hi_lna0 = 0x27, hi_lna1 = 0x27 mt76x2_reinit_hi_lna_gain:updated hi_lna0 = 0x27, hi_lna1 = 0x27 original vga value(chain0) = 5c original vga value(chain1) = 5c \u0026lt;==== rt28xx_init, Status=0 get_dev_name_prefix(): dev_idx = 1, dev_name_prefix=wdsi get_dev_name_prefix(): dev_idx = 1, dev_name_prefix=wdsi get_dev_name_prefix(): dev_idx = 1, dev_name_prefix=wdsi get_dev_name_prefix(): dev_idx = 1, dev_name_prefix=wdsi get_dev_name_prefix(): dev_idx = 1, dev_name_prefix=apclii RTMPDrvOpen(1):Check if PDMA is idle! RTMPDrvOpen(2):Check if PDMA is idle! ifconfig: ioctl 0x8913 failed: No such device brctl: bridge br0: No such device or address ##### configVIF ##### Raeth v3.1 (Tasklet) phy_tx_ring = 0x014d2000, tx_ring = 0xa14d2000 phy_rx_ring0 = 0x014d3000, rx_ring0 = 0xa14d3000 SMACCR1 -- : 0x0000e8d1 SMACCR0 -- : 0x1b075a79 CDMA_CSG_CFG = 81000000 GDMA1_FWD_CFG = 20710000 vconfig: ioctl error for rem: No such device vconfig: ioctl error for rem: No such device rmmod: 8021q: No such file or directory device eth2 entered promiscuous mode ##### config Ralink ESW vlan partition (LLLLW) ##### usb 1-1: new high speed USB device using rt3xxx-ehci and address 2 switch reg write offset=2004, value=ff0003 switch reg write offset=2104, value=ff0003 switch reg write offset=2204, value=ff0003 switch reg write offset=2304, value=ff0003 switch reg write offset=2404, value=ff0003 switch reg write offset=2504, value=ff0003 switch reg write offset=2010, value=810000c0 switch reg write offset=2110, value=810000c0 switch reg write offset=2210, value=810000c0 switch reg write offset=2310, value=810000c0 switch reg write offset=2410, value=810000c0 switch reg write offset=2510, value=810000c0 switch reg write offset=2610, value=81000000 switch reg write offset=2710, value=81000000 switch reg write offset=2604, value=20ff0003 switch reg write offset=2704, value=20ff0003 Special Tag Disabled switch reg write offset=2610, value=81000000 switch reg write offset=2014, value=10001 switch reg write offset=2114, value=10001 switch reg write offset=2214, valucdc_acm 1-1:1.2: This device cannot do calls on its own. It is not a modem. e=10001 switch reg write offset=2314, value=10001 switch reg write offset=2414cdc_acm 1-1:1.2: ttyACM0: USB ACM device , value=10002 switch reg write offset=2514, value=10001 REG_ESW_WT_MAC_ATC is 0x7ff0002 done. cdc_acm 1-1:1.4: This device cannot do calls on its own. It is not a modem. cdc_acm 1-1:1.4: ttyACM1: USB ACM device GobiNet 1-1:1.6: usb0: register \u0026#39;GobiNet\u0026#39; at usb-rt3xxx-1, GobiNet Ethernet Device, e2:d4:81:3d:2f:ff device ra0 entered promiscuous mode device eth2.1 entered promiscuous mode device rai0 entered promiscuous mode ##### enable 2nd wireless interface ##### cat: can\u0026#39;t open \u0026#39;/var/run/LteManager.status\u0026#39;: No such file or directory lted.sh (at+cmd) run ... cat: can\u0026#39;t open \u0026#39;/var/run/LteManager.status\u0026#39;: No such file or directory cat: can\u0026#39;t open \u0026#39;/var/run/LteManager.status\u0026#39;: No such file or directory data=[ up lted.sh set_lte_led] del_reg():/var/run/.ip_up.reg, lted.sh set_lte_led br0: port 3(rai0) entering listening state br0: port 3(rai0) entering listening state br0: port 2(eth2.1) entering listening state br0: port 2(eth2.1) entering listening state br0: port 1(ra0) entering listening state br0: port 1(ra0) entering listening state add_reg():/var/run/.ip_up.reg, lted.sh set_lte_led ifconfig: ioctl 0x8914 failed: Cannot assign requested address ifconfig: ioctl 0x8914 failed: Cannot assign requested address cat: can\u0026#39;t open \u0026#39;/var/run/LteManager.status\u0026#39;: No such file or directory cat: can\u0026#39;t open \u0026#39;/var/run/LteManager.status\u0026#39;: No such file or directory route: ioctl 0x890c failed: No such process killall: rt2860apd: no process killed route: ioctl 0x890c failed: No such process killall: rtinicapd: no process killed killall: wapid: no process killed iptables v1.4.10: Couldn\u0026#39;t load target `firewall\u0026#39;:File not found Try `iptables -h\u0026#39; or \u0026#39;iptables --help\u0026#39; for more information. Mason : *pbLinkState = false (17:30:24) Type 0x10 : result=65494 callendreason[0]=36 callendreason[1]=101 Type 0x11 : result=65494 callendreasontype[0]=0 callendreasontype[1]=0 callendreasontype[2]=0 callendreasontype[3]=0 iptables: No chain/target/match by that name. iptables v1.4.10: Couldn\u0026#39;t load target `firewall_input\u0026#39;:File not found Try `iptables -h\u0026#39; or \u0026#39;iptables --help\u0026#39; for more information. iptables: No chain/target/match by that name. creating qcqmi0 ++ /sbin/automount_lte.sh: qcqmi0, qcqmi0, add, ===================== usb device: usbdev1.2 path: vendor: 05c6 product: 9026 manufacturer: Askey LTE module iptables v1.4.10: Couldn\u0026#39;t load target `mac_filter\u0026#39;:File not found Try `iptables -h\u0026#39; or \u0026#39;iptables --help\u0026#39; for more information. iptables: No chain/target/match by that name. iptables v1.4.10: Couldn\u0026#39;t load target `ipport_filter\u0026#39;:File not found Try `iptables -h\u0026#39; or \u0026#39;iptables --help\u0026#39; for more information. iptables: No chain/target/match by that name. iptables v1.4.10: Couldn\u0026#39;t load target `web_filter\u0026#39;:File not found Try `iptables -h\u0026#39; or \u0026#39;iptables --help\u0026#39; for more information. iptables: No chain/target/match by that name. iptables v1.4.10: Couldn\u0026#39;t load target `malicious_filter\u0026#39;:File not found Try `iptables -h\u0026#39; or \u0026#39;iptables --help\u0026#39; for more information. iptables: No chain/target/match by that name. iptables v1.4.10: Couldn\u0026#39;t load target `malicious_input_filter\u0026#39;:File not found Try `iptables -h\u0026#39; or \u0026#39;iptables --help\u0026#39; for more information. iptables: No chain/target/match by that name. iptables v1.4.10: Couldn\u0026#39;t load target `port_trigger\u0026#39;:File not found Try `iptables -h\u0026#39; or \u0026#39;iptables --help\u0026#39; for more information. iptables: No chain/target/match by that name. iptables v1.4.10: Couldn\u0026#39;t load target `trigger_prerouting\u0026#39;:File not found Try `iptables -h\u0026#39; or \u0026#39;iptables --help\u0026#39; for more information. iptables: No chain/target/match by that name. cat: can\u0026#39;t open \u0026#39;/var/run/LteManager.status\u0026#39;: No such file or directory firewall.c:iptablesIPPortFilterRun:529:Warning: can\u0026#39;t find \u0026#34;IPPortFilterRules\u0026#34; in flash. firewall.c:iptablesMACFilterRun:449:Warning: can\u0026#39;t find \u0026#34;MacFilteringRules\u0026#34; in flash. cat: can\u0026#39;t open \u0026#39;/var/run/LteManager.status\u0026#39;: No such file or directory cat: can\u0026#39;t open \u0026#39;/var/run/LteManager.status\u0026#39;: No such file or directory cat: can\u0026#39;t open \u0026#39;/var/run/LteManager.status\u0026#39;: No such file or directory sh: /bin/super_dmz: not found iptables v1.4.10: Couldn\u0026#39;t load target `port_forward\u0026#39;:File not found Try `iptables -h\u0026#39; or \u0026#39;iptables --help\u0026#39; for more information. iptables: No chain/target/match by that name. iptables: No chain/target/match by that name. iptables v1.4.10: Couldn\u0026#39;t load target `port_forward\u0026#39;:File not found Try `iptables -h\u0026#39; or \u0026#39;iptables --help\u0026#39; for more information. iptables: No chain/target/match by that name. iptables: No chain/target/match by that name. iptables v1.4.10: Couldn\u0026#39;t load target `MINIUPNPD\u0026#39;:File not found Try `iptables -h\u0026#39; or \u0026#39;iptables --help\u0026#39; for more information. iptables v1.4.10: Couldn\u0026#39;t load target `DMZ\u0026#39;:File not found Try `iptables -h\u0026#39; or \u0026#39;iptables --help\u0026#39; for more information. iptables: No chain/target/match by that name. iptables v1.4.10: Couldn\u0026#39;t load target `vpn_passthrough\u0026#39;:File not found Try `iptables -h\u0026#39; or \u0026#39;iptables --help\u0026#39; for more information. iptables: No chain/target/match by that name. 30 0 180 0 HTTP/1.0 302 Redirect Pragma: no-cache Cache-Control: no-cache Content-Type: text/html Location: (null) my.pool.ntp.org: Unknown host syslogd: illegal option -- C BusyBox v1.12.1 (2017-10-16 17:28:06 CST) multi-call binary Usage: syslogd [OPTION]... cat: can\u0026#39;t open \u0026#39;/var/run/LteManager.status\u0026#39;: No such file or directory get_ipaddr: ioctl SIOCGIFADDR error for usb0 internet.c:ripd_restart:435:The WAN IP is still undeterminated... cat: can\u0026#39;t open \u0026#39;/var/run/LteManager.status\u0026#39;: No such file or directory 0 HTTP/1.0 302 Redirect Pragma: no-cache Cache-Control: no-cache Content-Type: text/html Location: (null) cat: can\u0026#39;t open \u0026#39;/var/run/LteManager.status\u0026#39;: No such file or directory Power LED On 33 data=[ up start_voip.sh] [auto fota] Start session connection after 4267 seconds del_reg():/var/run/.port_up.reg, start_voip.sh cat: can\u0026#39;t open \u0026#39;/var/run/LteManager.status\u0026#39;: No such file or directory init: can\u0026#39;t log to /dev/tty5 starting pid 4531, tty \u0026#39;/dev/ttyS1\u0026#39;: \u0026#39;/sbin/getty 57600 ttyS1\u0026#39; no osal_kernel: module license \u0026#39;D2 Technologies, Inc. Proprietary Software\u0026#39; taints kernel. Disabling lock debugging due to kernel taint [KEYMGR] Starting... osal_module.c:39 OSAL module_init OK lkm.c 178: devname /dev/d2vtspr /dev/d2vtspr registered successfuly @ 249. ralink login: ======== vPort Release +D2Tech+ VPORT WANG2_R_1_6_11 ======== D2 Technologies _ _ __ / | \u0026#39;/ /_ _ /_ _ _ /_ _ ._ _ /_.\u0026#39;/_ //_\u0026#39;/_ / // //_///_//_///_\u0026#39;_\\ _/ Unified Communication Products www.d2tech.com [keymgr] Bolt new board rev 5(RED RSSI LED) vapp_init.c:621 - hostname_ptr=192.168.1.123 vapp_init.c:661 VAPP hostname 192.168.1.123 (\u0026#39;192.168.1.123\u0026#39;) vapp_init.c:663 VAPP hostname 192.168.1.123 (hbo c0a8017b) _VAPP_initSetupSystem 767 - flashTmo = 5 _VAPP_initSetupSystem 1008 - MGMT port = 10000 Set reg status: Unregistered vapp_init: uname00= not set infc=0 appr=0 vapp_init: - forcing default uname00=000000001681920 vapp_init.c 1503: dname00 not set, defaulting to uname \u0026#39;000000001681920\u0026#39; vapp_init.c 1622 - dtmfType = 2, coderEnable[VAPP_CODER_DTMF] = 1 vapp_init.c: 1719 UA 0 is configured with these params: Hostname: 192.168.1.123 (hbo c0a8017b) HostAddr: 192.168.1.123 Authname: ******** Password: ******** Domain: ims.indosat.com Realm: ims.indosat.com Registrar: 202.62.29.166 Proxy : 202.62.29.166 Username[0]: ******** Dname[0]: ******** Channel 0: Revision Id 0xA2(0x18:0x2) Si3217x: Channel 0 : Type = PROSLIC si3217x : Channel 0 : Type = 24 si3217x : Channel 0 : Rev = 2 Si3217x: loading patch: 06182014 Si3217x: Channel 0 : VBAT Up = 58.375 v br0: port 3(rai0) entering learning state br0: port 2(eth2.1) entering learning state br0: port 1(ra0) entering learning state Si3217x: PCMStart vapp_vtsp.c: VTSP_getVersion reports v1.4.0 IOCTL_QMI_GET_SERVICE_FILE : arg=1 =============== result=1b01 =============== IOCTL_QMI_GET_SERVICE_FILE : arg=2 =============== result=202 =============== IOCTL_QMI_GET_SERVICE_FILE : arg=3 =============== result=303 =============== D2 Technologies, Inc. _ _ __ / | \u0026#39;/ /_ _ /_ _ _ /_ _ ._ _ /_.\u0026#39;/_ //_\u0026#39;/_ / // //_///_//_///_\u0026#39;_\\ _/ Unified Communication Products www.d2tech.com +D2Tech+ VTSP_RT WANG2_R_1_6_11 +D2Tech+ VTSP_RT WANG2_R_1_6_11 +D2Tech+ +D2Tech+ +D2Tech+ comm trunk-comm src-svn: 4647 d2tools-svn: 4647 +D2Tech+ +D2Tech+ +D2Tech+ +D2Tech+ +D2Tech+ +D2Tech+ +D2Tech+ tone M24KEC4_B_1_1-tone_1_2 src-svn: 225 d2tools-svn: 3454 +D2Tech+ +D2Tech+ +D2Tech+ +D2Tech+ _VHW_start 874 Start the TASKLET mode [LTE] -\u0026gt; LTE module found. Set call status: Idle [LTE] -\u0026gt; No SIM card. br0: topology change detected, propagating br0: port 3(rai0) entering forwarding state br0: topology change detected, propagating br0: port 2(eth2.1) entering forwarding state br0: topology change detected, propagating br0: port 1(ra0) entering forwarding state VTSPR_task 141 RealTime miss found in VTSPR tasklet mode ","permalink":"https://radito.github.io/posts/d52505f2-fd5b-4dd1-8286-fdc37c700cfb/","summary":"üí° Apa itu Router ?\nRouter adalah perangkat jaringan yang meneruskan paket data antara jaringan komputer. Router terhubung dengan setidaknya dua jaringan, biasanya dua LAN (Local Area Network) atau WAN (Wide Area Network) atau LAN dan jaringan ISP (Internet Service Provider) nya. Router terletak di gerbang, tempat di mana dua atau lebih jaringan terhubung.\n‚ú≥Ô∏è ToDo List Oprek\nAkses Port UART/Serial Rooting Firmware Bawaan Dump Firmware Bawaan Install Mod USB Port Install Firmware OpenWRT Konfigurasi modem LTE di OpenWRT ‚ú≥Ô∏è Router Bolt dengan Modem LTE","title":"Ngoprek Bolt BL-100"},{"content":" OpenWRT is a Linux-based open-source operating system designed for embedded devices such as routers. It is a free and customizable firmware that allows users to modify and extend the functionality of their routers beyond what the manufacturer provides. OpenWRT is popular among tech enthusiasts, developers, and network administrators due to its flexibility, stability, and security features.\nFeatures OpenWRT comes with a range of features that make it a popular choice for embedded devices. Some notable features include:\nPackage Management: OpenWRT has a built-in package management system that allows users to install, update, and remove software packages easily. This feature makes it easy for users to customize their routers according to their needs. Security: OpenWRT comes with several security features, including a built-in firewall, VPN support, and support for encryption protocols. These features help to secure your network and protect your data from unauthorized access. Customization: OpenWRT is highly customizable, allowing users to configure their routers to their specific needs. Users can modify the source code, install custom software packages, and even create their own firmware images. Stability: OpenWRT is known for its stability and reliability. It is designed to run for long periods without crashing, which makes it ideal for critical applications. Benefits OpenWRT has several benefits, including:\nFlexibility: With OpenWRT, users have complete control over their routers. They can customize their routers to their specific needs and even add new features. Security: OpenWRT comes with several security features that help to protect your network and data from cyber threats. Stability: OpenWRT is designed to run for long periods without crashing, which makes it ideal for critical applications. Community Support: OpenWRT has a large and active community of developers and users who provide support, share knowledge, and contribute to the development of the firmware. Conclusion OpenWRT is a powerful and flexible firmware that offers users complete control over their routers. With its built-in package management system, security features, and customization options, OpenWRT is a popular choice for tech enthusiasts, developers, and network administrators. Its stability and reliability make it ideal for critical applications, while its active community provides support and contributes to its development.\n","permalink":"https://radito.github.io/posts/423def8e-4caf-4d57-a782-2d9fc3d670ed/","summary":"OpenWRT is a Linux-based open-source operating system designed for embedded devices such as routers. It is a free and customizable firmware that allows users to modify and extend the functionality of their routers beyond what the manufacturer provides. OpenWRT is popular among tech enthusiasts, developers, and network administrators due to its flexibility, stability, and security features.\nFeatures OpenWRT comes with a range of features that make it a popular choice for embedded devices.","title":"OpenWRT"}]